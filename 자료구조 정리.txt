동적배열, 링크드리스트, 트리, 해쉬테이블의 일반적인 상황 비교

-- Add 속도 비교

동적배열 > 링크드리스트 > 해쉬테이블 > 트리

동적배열
: 배열 가장 마지막 인덱스 다음 인덱스 에 값을 대입하기만 함. 
크기가 모자랄때만 늘려줘야하므로 O(n) 이고 나머지 O(1) 

링크드 리스트
: 새로운 노드를 생성하여 마지막 노드 뒤에 대입하므로 
O(1) 이지만 
단순 값을 대입만 하고 끝내는 동적배열과 달리 
추가시 마다 노드 객체를 생성하고(동적할당) 노드의 값 대입 + 다른 노드의 주소도 저장해야하므로 
동적배열보다는 느림.

해쉬테이블
: 해쉬 함수를 통해 키값을 생성한 후에 배열의 해당 키 인덱스에 값을 대입하므로 
시간복잡도는 O(1) 이지만, 객체의 이름을 통해 모듈러 연산을 수행하는 간단한 해쉬함수를 쓰더라도,
for문으로 모든 문자를 검색해야하기떄문에 추가할 대상 객체에 따라 시간소요가
많이 늘어날 수도 있음.
충돌을 링크드리스트 체이닝 방식으로 처리할 경우 해당 링크드리스트에 추가하는 과정도 들어가므로 
링크드 리스트 보다 시간이 오래걸림.

트리
: 값의 크기를 비교해서 적합한 위치를 찾아야하고, 
노드하나를 검색할 때 마다 경우의 수가 1/2로 줄어듦으로 
이상적인 이진트리의 경우 O(logN) 이 걸림. 

-- insert 속도 비교

동적배열 > 링크드리스트

동적배열 : 
해당 인덱스부터 끝까지 모든 데이터를 주소 한칸 밀고 삽입하므로 반복문 사용필요, 
O(n) 만큼 걸림.

링크드리스트:
삽입 위치의 노드를 검색해야하므로 O(n) 만큼 걸리나, 
노드 검색 후 삽입시 링크들을 변경해주어야 하므로 동적배열보다는 느림.

해쉬테이블 : 
별도의 삽입 연산 없음 

트리 :
이진트리의 경우 별도의 삽입 연산 없음

-- Delete 속도비교

해시테이블 > 트리 > 동적배열 > 링크드리스트

동적배열 : 
해당 인덱스 지우고 이후 모든 데이터를 주소 한칸 당겨야 하므로 O(n) 만큼 걸림.

링크드리스트 :
삭제할 노드를 검색해야하므로 O(n) 걸리고,
삭제시 노드간 링크를 재연결 해주어야 하고 해당노드 메모리 해제/ 가비지콜렉팅 해야 하므로 동적배열보다는 오래걸림.

해시테이블 : 
해시함수로 인덱스 검색한 후 삭제하므로 O(1) 걸림. 

트리 : 
삭제할 노드를 검색하는데 O(logN) , 삭제후 해당위치 대체 노드를 찾는데도 시간이 걸리지만 O(logN) 보다 작으므로
총 O(LogN) 걸림.